#!/usr/bin/python3
import guestfs
import tarfile
from math import ceil

# This is how big the partition table is. The 34 assume 512byte sectors
GPT_OFFSET_SECTORS = 34

SIZE=8 # in gB
INPUT = "/mnt/endgame"
OUTPUT = "/export/disk.img"

offset = GPT_OFFSET_SECTORS

def generate_fstab(meta):
    """
    Generate /etc/fstab
    """
    ret = []

    ret.append("# Autogenerated by Reclaim LegacyBaseOS module")
    ret.append("# <file system>\t<mount point>\t<type>\t<options>\t<dump>\t<pass>")

    for partition, data in meta.items():
        uuid, vfs = g.vfs_uuid(partition), g.vfs_type(partition)
        mountpoint = data["mount"]
        options = data.get("options", "defaults")
        mdump, mpass = data.get("dump", 0), data.get("pass", 0)

        entry = "\t".join([
            "UUID="+uuid,
            mountpoint,
            vfs,
            options,
            str(mdump),
            str(mpass)
        ])

        ret.append(entry)

    # Use `tmpfs` to prevent the disk from filling.
    # Mount /tmp as `noexec` for security.
    ret.append("tmpfs\t/tmp\ttmpfs\trw,nodev,noexec,nosuid,size=2G\t0 0")

    with open("/tmp/fstab", "w") as f:
        f.write("\n".join(ret))

    g.copy_in("/tmp/fstab", "/etc/")

def add_partition(device, size = None):
    """
    Add an entry to the partition table
    """
    global offset
    SECTOR_SIZE = g.blockdev_getss(devices[0])
    SECTOR_COUNT = g.blockdev_getsz(devices[0])

    # According to the libguestfs doc, `getsz` always return
    # in 512bytes units, but the sector size 4kB sectors are
    # more and more common.
    if SECTOR_SIZE != 512:
        SECTOR_COUNT *= (SECTOR_SIZE/512)

    sectors = 0

    if size:
        size_bytes = size * pow(1024, 2)
        sectors = ceil(size_bytes / SECTOR_SIZE)
    else:
        # The -GPT_OFFSET_SECTORS is because the table needs
        # to be written at both end
        sectors = -GPT_OFFSET_SECTORS

    print("Create from %d to %d" % (offset, sectors))
    g.part_add(devices[0], "p", offset, sectors)

    offset += sectors + 1

# Create a tarball to avoid libguestfs copy rabbit hole
with tarfile.open("/img.tar.gz", "w:gz") as tar:
    print("Archiving the directory")
    tar.add(INPUT, arcname=".")
    print("Archive completed")

g = guestfs.GuestFS(python_return_dict=True)
g.set_network(True)
g.set_verbose(True)

# Yes, that's deprecated, but there is no other way to
# debug scripts using the exported API.
# g.set_direct(True)

g.disk_create(OUTPUT, "raw", SIZE * pow(1024, 3))
g.add_drive_opts(OUTPUT, format="raw", readonly=0)
print("Starting QEmu")
g.launch()
print("QEmu started")
devices = g.list_devices()

g.part_init(devices[0], "gpt")

add_partition(devices[0], 50)
add_partition(devices[0])

partitions = g.list_partitions()

g.mkfs("fat", partitions[0])
g.part_set_name(devices[0], 1, "EFI")
g.part_set_bootable(devices[0], 1, True)

g.mkfs("xfs", partitions[1])
g.part_set_name(devices[0], 2, "ROOT")

g.mount(partitions[1], "/")

print("Flashing the disk content")
g.tar_in("/img.tar.gz", "/", compress="gzip")
print("Flashing completed")

g.mkdir_p("/boot/efi/")
g.mkdir_p("/boot/grub/")
g.mount(partitions[0], "/boot/efi")

g.copy_in("/assets", "/")
g.copy_in("/scripts", "/")
g.copy_in("/filesystem", "/")

# Generate /etc/fstab
print(generate_fstab({
   "/dev/sda1": {
      "mount": "/boot/efi",
   },
   "/dev/sda2": {
      "mount": "/",
   }
}))

# Execute random scripts to convern the chroot base OS
# into a viable/bootable Linux image.
for x in g.ls("/scripts"):
    print("Execute", x)
    try:
        print(g.command(["/scripts/"+x]))
    except:
        print("Executing", x, "failed")

g.rm_rf("/assets")
g.rm_rf("/scripts")

g.shutdown()
g.close()
